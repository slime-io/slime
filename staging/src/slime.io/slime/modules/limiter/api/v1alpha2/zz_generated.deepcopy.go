//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha2

import (
	timex "time"

	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Duration) DeepCopyInto(out *Duration) {
	*out = *in
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Duration.
func (in *Duration) DeepCopy() *Duration {
	if in == nil {
		return nil
	}
	out := new(Duration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Limiter) DeepCopyInto(out *Limiter) {
	*out = *in
	if in.Refresh != nil {
		in, out := &in.Refresh, &out.Refresh
		*out = new(timex.Duration)
		**out = **in
	}
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Limiter.
func (in *Limiter) DeepCopy() *Limiter {
	if in == nil {
		return nil
	}
	out := new(Limiter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimitDescriptor) DeepCopyInto(out *SmartLimitDescriptor) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(SmartLimitDescriptor_Action)
		(*in).DeepCopyInto(*out)
	}
	if in.Match != nil {
		in, out := &in.Match, &out.Match
		*out = make([]*SmartLimitDescriptor_HeaderMatcher, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(SmartLimitDescriptor_HeaderMatcher)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(SmartLimitDescriptor_Target)
		(*in).DeepCopyInto(*out)
	}
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimitDescriptor.
func (in *SmartLimitDescriptor) DeepCopy() *SmartLimitDescriptor {
	if in == nil {
		return nil
	}
	out := new(SmartLimitDescriptor)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimitDescriptor_Action) DeepCopyInto(out *SmartLimitDescriptor_Action) {
	*out = *in
	if in.FillInterval != nil {
		in, out := &in.FillInterval, &out.FillInterval
		*out = new(Duration)
		(*in).DeepCopyInto(*out)
	}
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimitDescriptor_Action.
func (in *SmartLimitDescriptor_Action) DeepCopy() *SmartLimitDescriptor_Action {
	if in == nil {
		return nil
	}
	out := new(SmartLimitDescriptor_Action)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimitDescriptor_HeaderMatcher) DeepCopyInto(out *SmartLimitDescriptor_HeaderMatcher) {
	*out = *in
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimitDescriptor_HeaderMatcher.
func (in *SmartLimitDescriptor_HeaderMatcher) DeepCopy() *SmartLimitDescriptor_HeaderMatcher {
	if in == nil {
		return nil
	}
	out := new(SmartLimitDescriptor_HeaderMatcher)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimitDescriptor_Target) DeepCopyInto(out *SmartLimitDescriptor_Target) {
	*out = *in
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimitDescriptor_Target.
func (in *SmartLimitDescriptor_Target) DeepCopy() *SmartLimitDescriptor_Target {
	if in == nil {
		return nil
	}
	out := new(SmartLimitDescriptor_Target)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimitDescriptors) DeepCopyInto(out *SmartLimitDescriptors) {
	*out = *in
	if in.Descriptor_ != nil {
		in, out := &in.Descriptor_, &out.Descriptor_
		*out = make([]*SmartLimitDescriptor, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(SmartLimitDescriptor)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimitDescriptors.
func (in *SmartLimitDescriptors) DeepCopy() *SmartLimitDescriptors {
	if in == nil {
		return nil
	}
	out := new(SmartLimitDescriptors)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimiter) DeepCopyInto(out *SmartLimiter) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimiter.
func (in *SmartLimiter) DeepCopy() *SmartLimiter {
	if in == nil {
		return nil
	}
	out := new(SmartLimiter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SmartLimiter) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimiterList) DeepCopyInto(out *SmartLimiterList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SmartLimiter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimiterList.
func (in *SmartLimiterList) DeepCopy() *SmartLimiterList {
	if in == nil {
		return nil
	}
	out := new(SmartLimiterList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SmartLimiterList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimiterSpec) DeepCopyInto(out *SmartLimiterSpec) {
	*out = *in
	if in.Sets != nil {
		in, out := &in.Sets, &out.Sets
		*out = make(map[string]*SmartLimitDescriptors, len(*in))
		for key, val := range *in {
			var outVal *SmartLimitDescriptors
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(SmartLimitDescriptors)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimiterSpec.
func (in *SmartLimiterSpec) DeepCopy() *SmartLimiterSpec {
	if in == nil {
		return nil
	}
	out := new(SmartLimiterSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SmartLimiterStatus) DeepCopyInto(out *SmartLimiterStatus) {
	*out = *in
	if in.RatelimitStatus != nil {
		in, out := &in.RatelimitStatus, &out.RatelimitStatus
		*out = make(map[string]*SmartLimitDescriptors, len(*in))
		for key, val := range *in {
			var outVal *SmartLimitDescriptors
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(SmartLimitDescriptors)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	if in.MetricStatus != nil {
		in, out := &in.MetricStatus, &out.MetricStatus
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SmartLimiterStatus.
func (in *SmartLimiterStatus) DeepCopy() *SmartLimiterStatus {
	if in == nil {
		return nil
	}
	out := new(SmartLimiterStatus)
	in.DeepCopyInto(out)
	return out
}
